Архитектура

1. Source Layer
   PostgreSQL база dvdrental
   Подключение через postgres_fdw
   Данные импортированы в схему film_src

2. Staging Layer
   Схема: staging
   Назначение:
   промежуточное хранение данных
   минимальная обработка
   подготовка к загрузке в core слой

Особенности:
Полная загрузка для большинства таблиц
Инкрементальная загрузка для inventory
Поддержка soft delete (поле deleted)
Контроль загрузки через таблицу staging.last_update

Реализованные таблицы:
film
inventory
rental
payment
staff
address
city
store

Staging слой не содержит бизнес-логики и surrogate keys.

3. Core Layer (Star Schema)
   Реализована звездная схема по методологии Kimball.

Схема: core

Измерения (Dimensions)
dim_date
Календарное измерение, генерируется процедурой core.load_date.
Содержит:
день, месяц, квартал, год
week_of_year, ISO week
first/last day of period
признак выходного дня
dim_inventory

Измерение с реализацией Slowly Changing Dimension Type 2.

Поддерживает историзацию через:
effective_date_from
effective_date_to
is_active

При изменении записи создаётся новая версия строки с сохранением истории.
dim_staff

Измерение сотрудников.
Реализована стратегия полной перезагрузки.

Факты (Facts)
fact_payment
Факт платежей:
сумма оплаты
связь с датой оплаты
связь с сотрудником
связь с инвентарём

fact_rental
Факт аренды:
количество операций
сумма
дата аренды
дата возврата
Фактовые таблицы используют surrogate keys измерений.

4. Data Mart Layer

Схема: report

Реализованы агрегированные витрины:
report.sales_date — продажи по датам
report.sales_film — продажи по фильмам

Процедуры:
report.sales_date_calc()
report.sales_film_calc()

Стратегия загрузки

Используется гибридная стратегия:
Инкрементальная загрузка для staging.inventory
SCD Type 2 для core.dim_inventory
Полная перезагрузка для фактов
Генерация календаря через отдельную процедуру

5. Историчность в денормализованном измерении (dim_inventory)

В dim_inventory реализована расширенная историзация.
Особенность:
Измерение денормализовано — включает атрибуты из справочника film:
title
rental_duration
rental_rate
length
rating

Даже если inventory_id не менялся, изменение параметров фильма в источнике приводит к созданию новой версии строки в dim_inventory.

Алгоритм:
Получаем дату предыдущей загрузки film (предпоследнюю запись в staging.last_update).
Выбираем фильмы, изменённые с момента предыдущей загрузки.
Находим строки dim_inventory, период действия которых пересекается с датой изменения фильма.

Разделяем их:
старые версии закрываем (effective_date_to = дата изменения)
добавляем новые версии с обновлёнными параметрами фильма

Таким образом:
сохраняется историческая корректность
факт аренды всегда связан с верной версией измерения
поддерживается SCD Type 2 в денормализованной структуре

Инкрементальная загрузка для таблицы film не используется.
Фильм загружается полностью каждый раз, так как является справочником.

6. Инкрементальная загрузка и историчность фактов

Проблема
Фактовые таблицы занимают основной объем хранилища (до 90%).
Полная перезагрузка фактов:
увеличивает время загрузки
создаёт риски нарушения ссылочной целостности
не позволяет отслеживать изменения задним числом

Решение
Реализовано:
Инкрементальная загрузка staging.rental
SCD Type 2 в таблице core.fact_rental
Поддержка Soft delete
Единое время начала загрузки (current_update_dt)

1. Централизация логики контроля загрузки
   Созданы:
   staging.get_last_update_table(table_name)
   staging.set_table_load_time(table_name, current_update_dt)
   Это позволило:
   убрать дублирование INSERT в staging.last_update
   стандартизировать получение времени предыдущей загрузки
   сделать код компактным и читаемым

2. Единое время загрузки
   В процедуре full_load():
   declare current_update_dt timestamp = now();

Это время передается во все staging процедуры.
Решает проблему несогласованности данных:
Если фильм создан в 10:02, а inventory загружается в 10:05 -
он не попадет без общего времени отсечения.
Теперь все загружается относительно одного timestamp.

3. Инкрементальная загрузка staging.rental
   Загружаются только строки:

where
last_update >= last_update_dt
or deleted >= last_update_dt

Поддерживается soft delete через поле deleted.

4. Историчность в фактах (SCD Type 2)
   В core.fact_rental добавлены поля:
   effective_date_from timestamp
   effective_date_to timestamp
   is_active boolean

Когда создается новая версия факта?
Если изменились:
staff_id
inventory_id
rental_date
return_date (если уже была и изменилась)

Не создается новая строка, если:
return_date была NULL и просто заполнилась впервые

Алгоритм обработки
Помечаем удаленные строки неактивными
Вставляем новые rental_id
Обновляем return_date, если ранее было NULL
Закрываем измененные версии (is_active = false)
Вставляем новую версию факта

5. Удалена полная очистка фактов
   Удалена процедура:
   core.fact_delete()
   Так как:
   измерения теперь грузятся инкрементально
   удаление фактов больше не требуется

6. Практическая ценность
   Историчность фактов реализована для поддержки аудита изменений.
   Это позволяет объяснять расхождения в отчетах между разными датами построения.

full_load() использует единый current_update_dt для согласованной фиксации времени загрузки staging слоя.
